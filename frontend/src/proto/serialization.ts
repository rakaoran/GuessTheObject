// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v5.29.3
// source: src/proto/serialization.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "protobuf";

export interface ServerPacket {
  drawingData?: DrawingData | undefined;
  playerJoined?: ServerPacket_PlayerJoined | undefined;
  gameStarted?: ServerPacket_GameStarted | undefined;
  roundUpdate?: ServerPacket_RoundUpdate | undefined;
  playerIsChoosingWord?: ServerPacket_PlayerIsChoosingWord | undefined;
  playerIsDrawing?: ServerPacket_PlayerIsDrawing | undefined;
  turnSummary?: ServerPacket_TurnSummary | undefined;
  playerGuessedTheWord?: ServerPacket_PlayerGuessedTheWord | undefined;
  leaderboard?: ServerPacket_LeaderBoard | undefined;
  playerMessage?: ServerPacket_PlayerMessage | undefined;
  pleaseChooseAWord?: ServerPacket_PleaseChooseAWord | undefined;
  initialRoomSnapshot?: ServerPacket_InitialRoomSnapshot | undefined;
  yourTurnToDraw?: ServerPacket_YourTurnToDraw | undefined;
  playerLeft?: ServerPacket_PlayerLeft | undefined;
  serverTimestamp: number;
}

export interface ServerPacket_YourTurnToDraw {
  word: string;
}

export interface ServerPacket_InitialRoomSnapshot {
  playersStates: ServerPacket_InitialRoomSnapshot_PlayerState[];
  drawingHistory: Uint8Array[];
  currentDrawer: string;
  currentRound: number;
  roomId: string;
  nextTick: number;
  choosingWordDuration: number;
  drawingDuration: number;
  currentPhase: number;
}

export interface ServerPacket_InitialRoomSnapshot_PlayerState {
  username: string;
  score: number;
  isGuesser: boolean;
}

export interface ServerPacket_PlayerJoined {
  username: string;
}

export interface ServerPacket_PlayerLeft {
  username: string;
}

export interface ServerPacket_GameStarted {
}

export interface ServerPacket_RoundUpdate {
  roundNumber: number;
}

export interface ServerPacket_PlayerIsChoosingWord {
  username: string;
}

export interface ServerPacket_PlayerIsDrawing {
  username: string;
}

export interface ServerPacket_TurnSummary {
  wordReveal: string;
  deltas: ServerPacket_TurnSummary_ScoreDeltas[];
}

export interface ServerPacket_TurnSummary_ScoreDeltas {
  username: string;
  scoreDelta: number;
}

export interface ServerPacket_PlayerGuessedTheWord {
  username: string;
}

export interface ServerPacket_LeaderBoard {
}

export interface ServerPacket_PlayerMessage {
  from: string;
  message: string;
}

export interface ServerPacket_PleaseChooseAWord {
  words: string[];
}

export interface ClientPacket {
  drawingData?: DrawingData | undefined;
  playerMessage?: ClientPacket_PlayerMessage | undefined;
  wordChoice?: ClientPacket_WordChoice | undefined;
  startGame?: ClientPacket_StartGame | undefined;
}

export interface ClientPacket_StartGame {
}

export interface ClientPacket_WordChoice {
  choice: number;
}

export interface ClientPacket_PlayerMessage {
  message: string;
}

export interface DrawingData {
  data: Uint8Array;
}

function createBaseServerPacket(): ServerPacket {
  return {
    drawingData: undefined,
    playerJoined: undefined,
    gameStarted: undefined,
    roundUpdate: undefined,
    playerIsChoosingWord: undefined,
    playerIsDrawing: undefined,
    turnSummary: undefined,
    playerGuessedTheWord: undefined,
    leaderboard: undefined,
    playerMessage: undefined,
    pleaseChooseAWord: undefined,
    initialRoomSnapshot: undefined,
    yourTurnToDraw: undefined,
    playerLeft: undefined,
    serverTimestamp: 0,
  };
}

export const ServerPacket: MessageFns<ServerPacket> = {
  encode(message: ServerPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.drawingData !== undefined) {
      DrawingData.encode(message.drawingData, writer.uint32(10).fork()).join();
    }
    if (message.playerJoined !== undefined) {
      ServerPacket_PlayerJoined.encode(message.playerJoined, writer.uint32(18).fork()).join();
    }
    if (message.gameStarted !== undefined) {
      ServerPacket_GameStarted.encode(message.gameStarted, writer.uint32(26).fork()).join();
    }
    if (message.roundUpdate !== undefined) {
      ServerPacket_RoundUpdate.encode(message.roundUpdate, writer.uint32(34).fork()).join();
    }
    if (message.playerIsChoosingWord !== undefined) {
      ServerPacket_PlayerIsChoosingWord.encode(message.playerIsChoosingWord, writer.uint32(42).fork()).join();
    }
    if (message.playerIsDrawing !== undefined) {
      ServerPacket_PlayerIsDrawing.encode(message.playerIsDrawing, writer.uint32(50).fork()).join();
    }
    if (message.turnSummary !== undefined) {
      ServerPacket_TurnSummary.encode(message.turnSummary, writer.uint32(58).fork()).join();
    }
    if (message.playerGuessedTheWord !== undefined) {
      ServerPacket_PlayerGuessedTheWord.encode(message.playerGuessedTheWord, writer.uint32(66).fork()).join();
    }
    if (message.leaderboard !== undefined) {
      ServerPacket_LeaderBoard.encode(message.leaderboard, writer.uint32(74).fork()).join();
    }
    if (message.playerMessage !== undefined) {
      ServerPacket_PlayerMessage.encode(message.playerMessage, writer.uint32(82).fork()).join();
    }
    if (message.pleaseChooseAWord !== undefined) {
      ServerPacket_PleaseChooseAWord.encode(message.pleaseChooseAWord, writer.uint32(90).fork()).join();
    }
    if (message.initialRoomSnapshot !== undefined) {
      ServerPacket_InitialRoomSnapshot.encode(message.initialRoomSnapshot, writer.uint32(98).fork()).join();
    }
    if (message.yourTurnToDraw !== undefined) {
      ServerPacket_YourTurnToDraw.encode(message.yourTurnToDraw, writer.uint32(106).fork()).join();
    }
    if (message.playerLeft !== undefined) {
      ServerPacket_PlayerLeft.encode(message.playerLeft, writer.uint32(114).fork()).join();
    }
    if (message.serverTimestamp !== 0) {
      writer.uint32(128).int64(message.serverTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.drawingData = DrawingData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerJoined = ServerPacket_PlayerJoined.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gameStarted = ServerPacket_GameStarted.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.roundUpdate = ServerPacket_RoundUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.playerIsChoosingWord = ServerPacket_PlayerIsChoosingWord.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.playerIsDrawing = ServerPacket_PlayerIsDrawing.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.turnSummary = ServerPacket_TurnSummary.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.playerGuessedTheWord = ServerPacket_PlayerGuessedTheWord.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.leaderboard = ServerPacket_LeaderBoard.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.playerMessage = ServerPacket_PlayerMessage.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.pleaseChooseAWord = ServerPacket_PleaseChooseAWord.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.initialRoomSnapshot = ServerPacket_InitialRoomSnapshot.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.yourTurnToDraw = ServerPacket_YourTurnToDraw.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.playerLeft = ServerPacket_PlayerLeft.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.serverTimestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket {
    return {
      drawingData: isSet(object.drawingData) ? DrawingData.fromJSON(object.drawingData) : undefined,
      playerJoined: isSet(object.playerJoined) ? ServerPacket_PlayerJoined.fromJSON(object.playerJoined) : undefined,
      gameStarted: isSet(object.gameStarted) ? ServerPacket_GameStarted.fromJSON(object.gameStarted) : undefined,
      roundUpdate: isSet(object.roundUpdate) ? ServerPacket_RoundUpdate.fromJSON(object.roundUpdate) : undefined,
      playerIsChoosingWord: isSet(object.playerIsChoosingWord)
        ? ServerPacket_PlayerIsChoosingWord.fromJSON(object.playerIsChoosingWord)
        : undefined,
      playerIsDrawing: isSet(object.playerIsDrawing)
        ? ServerPacket_PlayerIsDrawing.fromJSON(object.playerIsDrawing)
        : undefined,
      turnSummary: isSet(object.turnSummary) ? ServerPacket_TurnSummary.fromJSON(object.turnSummary) : undefined,
      playerGuessedTheWord: isSet(object.playerGuessedTheWord)
        ? ServerPacket_PlayerGuessedTheWord.fromJSON(object.playerGuessedTheWord)
        : undefined,
      leaderboard: isSet(object.leaderboard) ? ServerPacket_LeaderBoard.fromJSON(object.leaderboard) : undefined,
      playerMessage: isSet(object.playerMessage)
        ? ServerPacket_PlayerMessage.fromJSON(object.playerMessage)
        : undefined,
      pleaseChooseAWord: isSet(object.pleaseChooseAWord)
        ? ServerPacket_PleaseChooseAWord.fromJSON(object.pleaseChooseAWord)
        : undefined,
      initialRoomSnapshot: isSet(object.initialRoomSnapshot)
        ? ServerPacket_InitialRoomSnapshot.fromJSON(object.initialRoomSnapshot)
        : undefined,
      yourTurnToDraw: isSet(object.yourTurnToDraw)
        ? ServerPacket_YourTurnToDraw.fromJSON(object.yourTurnToDraw)
        : undefined,
      playerLeft: isSet(object.playerLeft) ? ServerPacket_PlayerLeft.fromJSON(object.playerLeft) : undefined,
      serverTimestamp: isSet(object.serverTimestamp) ? globalThis.Number(object.serverTimestamp) : 0,
    };
  },

  toJSON(message: ServerPacket): unknown {
    const obj: any = {};
    if (message.drawingData !== undefined) {
      obj.drawingData = DrawingData.toJSON(message.drawingData);
    }
    if (message.playerJoined !== undefined) {
      obj.playerJoined = ServerPacket_PlayerJoined.toJSON(message.playerJoined);
    }
    if (message.gameStarted !== undefined) {
      obj.gameStarted = ServerPacket_GameStarted.toJSON(message.gameStarted);
    }
    if (message.roundUpdate !== undefined) {
      obj.roundUpdate = ServerPacket_RoundUpdate.toJSON(message.roundUpdate);
    }
    if (message.playerIsChoosingWord !== undefined) {
      obj.playerIsChoosingWord = ServerPacket_PlayerIsChoosingWord.toJSON(message.playerIsChoosingWord);
    }
    if (message.playerIsDrawing !== undefined) {
      obj.playerIsDrawing = ServerPacket_PlayerIsDrawing.toJSON(message.playerIsDrawing);
    }
    if (message.turnSummary !== undefined) {
      obj.turnSummary = ServerPacket_TurnSummary.toJSON(message.turnSummary);
    }
    if (message.playerGuessedTheWord !== undefined) {
      obj.playerGuessedTheWord = ServerPacket_PlayerGuessedTheWord.toJSON(message.playerGuessedTheWord);
    }
    if (message.leaderboard !== undefined) {
      obj.leaderboard = ServerPacket_LeaderBoard.toJSON(message.leaderboard);
    }
    if (message.playerMessage !== undefined) {
      obj.playerMessage = ServerPacket_PlayerMessage.toJSON(message.playerMessage);
    }
    if (message.pleaseChooseAWord !== undefined) {
      obj.pleaseChooseAWord = ServerPacket_PleaseChooseAWord.toJSON(message.pleaseChooseAWord);
    }
    if (message.initialRoomSnapshot !== undefined) {
      obj.initialRoomSnapshot = ServerPacket_InitialRoomSnapshot.toJSON(message.initialRoomSnapshot);
    }
    if (message.yourTurnToDraw !== undefined) {
      obj.yourTurnToDraw = ServerPacket_YourTurnToDraw.toJSON(message.yourTurnToDraw);
    }
    if (message.playerLeft !== undefined) {
      obj.playerLeft = ServerPacket_PlayerLeft.toJSON(message.playerLeft);
    }
    if (message.serverTimestamp !== 0) {
      obj.serverTimestamp = Math.round(message.serverTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket>, I>>(base?: I): ServerPacket {
    return ServerPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket>, I>>(object: I): ServerPacket {
    const message = createBaseServerPacket();
    message.drawingData = (object.drawingData !== undefined && object.drawingData !== null)
      ? DrawingData.fromPartial(object.drawingData)
      : undefined;
    message.playerJoined = (object.playerJoined !== undefined && object.playerJoined !== null)
      ? ServerPacket_PlayerJoined.fromPartial(object.playerJoined)
      : undefined;
    message.gameStarted = (object.gameStarted !== undefined && object.gameStarted !== null)
      ? ServerPacket_GameStarted.fromPartial(object.gameStarted)
      : undefined;
    message.roundUpdate = (object.roundUpdate !== undefined && object.roundUpdate !== null)
      ? ServerPacket_RoundUpdate.fromPartial(object.roundUpdate)
      : undefined;
    message.playerIsChoosingWord = (object.playerIsChoosingWord !== undefined && object.playerIsChoosingWord !== null)
      ? ServerPacket_PlayerIsChoosingWord.fromPartial(object.playerIsChoosingWord)
      : undefined;
    message.playerIsDrawing = (object.playerIsDrawing !== undefined && object.playerIsDrawing !== null)
      ? ServerPacket_PlayerIsDrawing.fromPartial(object.playerIsDrawing)
      : undefined;
    message.turnSummary = (object.turnSummary !== undefined && object.turnSummary !== null)
      ? ServerPacket_TurnSummary.fromPartial(object.turnSummary)
      : undefined;
    message.playerGuessedTheWord = (object.playerGuessedTheWord !== undefined && object.playerGuessedTheWord !== null)
      ? ServerPacket_PlayerGuessedTheWord.fromPartial(object.playerGuessedTheWord)
      : undefined;
    message.leaderboard = (object.leaderboard !== undefined && object.leaderboard !== null)
      ? ServerPacket_LeaderBoard.fromPartial(object.leaderboard)
      : undefined;
    message.playerMessage = (object.playerMessage !== undefined && object.playerMessage !== null)
      ? ServerPacket_PlayerMessage.fromPartial(object.playerMessage)
      : undefined;
    message.pleaseChooseAWord = (object.pleaseChooseAWord !== undefined && object.pleaseChooseAWord !== null)
      ? ServerPacket_PleaseChooseAWord.fromPartial(object.pleaseChooseAWord)
      : undefined;
    message.initialRoomSnapshot = (object.initialRoomSnapshot !== undefined && object.initialRoomSnapshot !== null)
      ? ServerPacket_InitialRoomSnapshot.fromPartial(object.initialRoomSnapshot)
      : undefined;
    message.yourTurnToDraw = (object.yourTurnToDraw !== undefined && object.yourTurnToDraw !== null)
      ? ServerPacket_YourTurnToDraw.fromPartial(object.yourTurnToDraw)
      : undefined;
    message.playerLeft = (object.playerLeft !== undefined && object.playerLeft !== null)
      ? ServerPacket_PlayerLeft.fromPartial(object.playerLeft)
      : undefined;
    message.serverTimestamp = object.serverTimestamp ?? 0;
    return message;
  },
};

function createBaseServerPacket_YourTurnToDraw(): ServerPacket_YourTurnToDraw {
  return { word: "" };
}

export const ServerPacket_YourTurnToDraw: MessageFns<ServerPacket_YourTurnToDraw> = {
  encode(message: ServerPacket_YourTurnToDraw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.word !== "") {
      writer.uint32(10).string(message.word);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_YourTurnToDraw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_YourTurnToDraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.word = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_YourTurnToDraw {
    return { word: isSet(object.word) ? globalThis.String(object.word) : "" };
  },

  toJSON(message: ServerPacket_YourTurnToDraw): unknown {
    const obj: any = {};
    if (message.word !== "") {
      obj.word = message.word;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_YourTurnToDraw>, I>>(base?: I): ServerPacket_YourTurnToDraw {
    return ServerPacket_YourTurnToDraw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_YourTurnToDraw>, I>>(object: I): ServerPacket_YourTurnToDraw {
    const message = createBaseServerPacket_YourTurnToDraw();
    message.word = object.word ?? "";
    return message;
  },
};

function createBaseServerPacket_InitialRoomSnapshot(): ServerPacket_InitialRoomSnapshot {
  return {
    playersStates: [],
    drawingHistory: [],
    currentDrawer: "",
    currentRound: 0,
    roomId: "",
    nextTick: 0,
    choosingWordDuration: 0,
    drawingDuration: 0,
    currentPhase: 0,
  };
}

export const ServerPacket_InitialRoomSnapshot: MessageFns<ServerPacket_InitialRoomSnapshot> = {
  encode(message: ServerPacket_InitialRoomSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playersStates) {
      ServerPacket_InitialRoomSnapshot_PlayerState.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.drawingHistory) {
      writer.uint32(18).bytes(v!);
    }
    if (message.currentDrawer !== "") {
      writer.uint32(26).string(message.currentDrawer);
    }
    if (message.currentRound !== 0) {
      writer.uint32(32).int32(message.currentRound);
    }
    if (message.roomId !== "") {
      writer.uint32(42).string(message.roomId);
    }
    if (message.nextTick !== 0) {
      writer.uint32(48).int64(message.nextTick);
    }
    if (message.choosingWordDuration !== 0) {
      writer.uint32(56).int64(message.choosingWordDuration);
    }
    if (message.drawingDuration !== 0) {
      writer.uint32(64).int64(message.drawingDuration);
    }
    if (message.currentPhase !== 0) {
      writer.uint32(72).int32(message.currentPhase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_InitialRoomSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_InitialRoomSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playersStates.push(ServerPacket_InitialRoomSnapshot_PlayerState.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.drawingHistory.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentDrawer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.currentRound = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nextTick = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.choosingWordDuration = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.drawingDuration = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.currentPhase = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_InitialRoomSnapshot {
    return {
      playersStates: globalThis.Array.isArray(object?.playersStates)
        ? object.playersStates.map((e: any) => ServerPacket_InitialRoomSnapshot_PlayerState.fromJSON(e))
        : [],
      drawingHistory: globalThis.Array.isArray(object?.drawingHistory)
        ? object.drawingHistory.map((e: any) => bytesFromBase64(e))
        : [],
      currentDrawer: isSet(object.currentDrawer) ? globalThis.String(object.currentDrawer) : "",
      currentRound: isSet(object.currentRound) ? globalThis.Number(object.currentRound) : 0,
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      nextTick: isSet(object.nextTick) ? globalThis.Number(object.nextTick) : 0,
      choosingWordDuration: isSet(object.choosingWordDuration) ? globalThis.Number(object.choosingWordDuration) : 0,
      drawingDuration: isSet(object.drawingDuration) ? globalThis.Number(object.drawingDuration) : 0,
      currentPhase: isSet(object.currentPhase) ? globalThis.Number(object.currentPhase) : 0,
    };
  },

  toJSON(message: ServerPacket_InitialRoomSnapshot): unknown {
    const obj: any = {};
    if (message.playersStates?.length) {
      obj.playersStates = message.playersStates.map((e) => ServerPacket_InitialRoomSnapshot_PlayerState.toJSON(e));
    }
    if (message.drawingHistory?.length) {
      obj.drawingHistory = message.drawingHistory.map((e) => base64FromBytes(e));
    }
    if (message.currentDrawer !== "") {
      obj.currentDrawer = message.currentDrawer;
    }
    if (message.currentRound !== 0) {
      obj.currentRound = Math.round(message.currentRound);
    }
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.nextTick !== 0) {
      obj.nextTick = Math.round(message.nextTick);
    }
    if (message.choosingWordDuration !== 0) {
      obj.choosingWordDuration = Math.round(message.choosingWordDuration);
    }
    if (message.drawingDuration !== 0) {
      obj.drawingDuration = Math.round(message.drawingDuration);
    }
    if (message.currentPhase !== 0) {
      obj.currentPhase = Math.round(message.currentPhase);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_InitialRoomSnapshot>, I>>(
    base?: I,
  ): ServerPacket_InitialRoomSnapshot {
    return ServerPacket_InitialRoomSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_InitialRoomSnapshot>, I>>(
    object: I,
  ): ServerPacket_InitialRoomSnapshot {
    const message = createBaseServerPacket_InitialRoomSnapshot();
    message.playersStates =
      object.playersStates?.map((e) => ServerPacket_InitialRoomSnapshot_PlayerState.fromPartial(e)) || [];
    message.drawingHistory = object.drawingHistory?.map((e) => e) || [];
    message.currentDrawer = object.currentDrawer ?? "";
    message.currentRound = object.currentRound ?? 0;
    message.roomId = object.roomId ?? "";
    message.nextTick = object.nextTick ?? 0;
    message.choosingWordDuration = object.choosingWordDuration ?? 0;
    message.drawingDuration = object.drawingDuration ?? 0;
    message.currentPhase = object.currentPhase ?? 0;
    return message;
  },
};

function createBaseServerPacket_InitialRoomSnapshot_PlayerState(): ServerPacket_InitialRoomSnapshot_PlayerState {
  return { username: "", score: 0, isGuesser: false };
}

export const ServerPacket_InitialRoomSnapshot_PlayerState: MessageFns<ServerPacket_InitialRoomSnapshot_PlayerState> = {
  encode(
    message: ServerPacket_InitialRoomSnapshot_PlayerState,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.score !== 0) {
      writer.uint32(16).int64(message.score);
    }
    if (message.isGuesser !== false) {
      writer.uint32(24).bool(message.isGuesser);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_InitialRoomSnapshot_PlayerState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_InitialRoomSnapshot_PlayerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isGuesser = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_InitialRoomSnapshot_PlayerState {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      isGuesser: isSet(object.isGuesser) ? globalThis.Boolean(object.isGuesser) : false,
    };
  },

  toJSON(message: ServerPacket_InitialRoomSnapshot_PlayerState): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.isGuesser !== false) {
      obj.isGuesser = message.isGuesser;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_InitialRoomSnapshot_PlayerState>, I>>(
    base?: I,
  ): ServerPacket_InitialRoomSnapshot_PlayerState {
    return ServerPacket_InitialRoomSnapshot_PlayerState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_InitialRoomSnapshot_PlayerState>, I>>(
    object: I,
  ): ServerPacket_InitialRoomSnapshot_PlayerState {
    const message = createBaseServerPacket_InitialRoomSnapshot_PlayerState();
    message.username = object.username ?? "";
    message.score = object.score ?? 0;
    message.isGuesser = object.isGuesser ?? false;
    return message;
  },
};

function createBaseServerPacket_PlayerJoined(): ServerPacket_PlayerJoined {
  return { username: "" };
}

export const ServerPacket_PlayerJoined: MessageFns<ServerPacket_PlayerJoined> = {
  encode(message: ServerPacket_PlayerJoined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_PlayerJoined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_PlayerJoined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_PlayerJoined {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: ServerPacket_PlayerJoined): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_PlayerJoined>, I>>(base?: I): ServerPacket_PlayerJoined {
    return ServerPacket_PlayerJoined.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_PlayerJoined>, I>>(object: I): ServerPacket_PlayerJoined {
    const message = createBaseServerPacket_PlayerJoined();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseServerPacket_PlayerLeft(): ServerPacket_PlayerLeft {
  return { username: "" };
}

export const ServerPacket_PlayerLeft: MessageFns<ServerPacket_PlayerLeft> = {
  encode(message: ServerPacket_PlayerLeft, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_PlayerLeft {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_PlayerLeft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_PlayerLeft {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: ServerPacket_PlayerLeft): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_PlayerLeft>, I>>(base?: I): ServerPacket_PlayerLeft {
    return ServerPacket_PlayerLeft.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_PlayerLeft>, I>>(object: I): ServerPacket_PlayerLeft {
    const message = createBaseServerPacket_PlayerLeft();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseServerPacket_GameStarted(): ServerPacket_GameStarted {
  return {};
}

export const ServerPacket_GameStarted: MessageFns<ServerPacket_GameStarted> = {
  encode(_: ServerPacket_GameStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_GameStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_GameStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ServerPacket_GameStarted {
    return {};
  },

  toJSON(_: ServerPacket_GameStarted): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_GameStarted>, I>>(base?: I): ServerPacket_GameStarted {
    return ServerPacket_GameStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_GameStarted>, I>>(_: I): ServerPacket_GameStarted {
    const message = createBaseServerPacket_GameStarted();
    return message;
  },
};

function createBaseServerPacket_RoundUpdate(): ServerPacket_RoundUpdate {
  return { roundNumber: 0 };
}

export const ServerPacket_RoundUpdate: MessageFns<ServerPacket_RoundUpdate> = {
  encode(message: ServerPacket_RoundUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roundNumber !== 0) {
      writer.uint32(8).int64(message.roundNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_RoundUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_RoundUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roundNumber = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_RoundUpdate {
    return { roundNumber: isSet(object.roundNumber) ? globalThis.Number(object.roundNumber) : 0 };
  },

  toJSON(message: ServerPacket_RoundUpdate): unknown {
    const obj: any = {};
    if (message.roundNumber !== 0) {
      obj.roundNumber = Math.round(message.roundNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_RoundUpdate>, I>>(base?: I): ServerPacket_RoundUpdate {
    return ServerPacket_RoundUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_RoundUpdate>, I>>(object: I): ServerPacket_RoundUpdate {
    const message = createBaseServerPacket_RoundUpdate();
    message.roundNumber = object.roundNumber ?? 0;
    return message;
  },
};

function createBaseServerPacket_PlayerIsChoosingWord(): ServerPacket_PlayerIsChoosingWord {
  return { username: "" };
}

export const ServerPacket_PlayerIsChoosingWord: MessageFns<ServerPacket_PlayerIsChoosingWord> = {
  encode(message: ServerPacket_PlayerIsChoosingWord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_PlayerIsChoosingWord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_PlayerIsChoosingWord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_PlayerIsChoosingWord {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: ServerPacket_PlayerIsChoosingWord): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_PlayerIsChoosingWord>, I>>(
    base?: I,
  ): ServerPacket_PlayerIsChoosingWord {
    return ServerPacket_PlayerIsChoosingWord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_PlayerIsChoosingWord>, I>>(
    object: I,
  ): ServerPacket_PlayerIsChoosingWord {
    const message = createBaseServerPacket_PlayerIsChoosingWord();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseServerPacket_PlayerIsDrawing(): ServerPacket_PlayerIsDrawing {
  return { username: "" };
}

export const ServerPacket_PlayerIsDrawing: MessageFns<ServerPacket_PlayerIsDrawing> = {
  encode(message: ServerPacket_PlayerIsDrawing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_PlayerIsDrawing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_PlayerIsDrawing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_PlayerIsDrawing {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: ServerPacket_PlayerIsDrawing): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_PlayerIsDrawing>, I>>(base?: I): ServerPacket_PlayerIsDrawing {
    return ServerPacket_PlayerIsDrawing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_PlayerIsDrawing>, I>>(object: I): ServerPacket_PlayerIsDrawing {
    const message = createBaseServerPacket_PlayerIsDrawing();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseServerPacket_TurnSummary(): ServerPacket_TurnSummary {
  return { wordReveal: "", deltas: [] };
}

export const ServerPacket_TurnSummary: MessageFns<ServerPacket_TurnSummary> = {
  encode(message: ServerPacket_TurnSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wordReveal !== "") {
      writer.uint32(10).string(message.wordReveal);
    }
    for (const v of message.deltas) {
      ServerPacket_TurnSummary_ScoreDeltas.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_TurnSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_TurnSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wordReveal = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deltas.push(ServerPacket_TurnSummary_ScoreDeltas.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_TurnSummary {
    return {
      wordReveal: isSet(object.wordReveal) ? globalThis.String(object.wordReveal) : "",
      deltas: globalThis.Array.isArray(object?.deltas)
        ? object.deltas.map((e: any) => ServerPacket_TurnSummary_ScoreDeltas.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServerPacket_TurnSummary): unknown {
    const obj: any = {};
    if (message.wordReveal !== "") {
      obj.wordReveal = message.wordReveal;
    }
    if (message.deltas?.length) {
      obj.deltas = message.deltas.map((e) => ServerPacket_TurnSummary_ScoreDeltas.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_TurnSummary>, I>>(base?: I): ServerPacket_TurnSummary {
    return ServerPacket_TurnSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_TurnSummary>, I>>(object: I): ServerPacket_TurnSummary {
    const message = createBaseServerPacket_TurnSummary();
    message.wordReveal = object.wordReveal ?? "";
    message.deltas = object.deltas?.map((e) => ServerPacket_TurnSummary_ScoreDeltas.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServerPacket_TurnSummary_ScoreDeltas(): ServerPacket_TurnSummary_ScoreDeltas {
  return { username: "", scoreDelta: 0 };
}

export const ServerPacket_TurnSummary_ScoreDeltas: MessageFns<ServerPacket_TurnSummary_ScoreDeltas> = {
  encode(message: ServerPacket_TurnSummary_ScoreDeltas, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.scoreDelta !== 0) {
      writer.uint32(16).int64(message.scoreDelta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_TurnSummary_ScoreDeltas {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_TurnSummary_ScoreDeltas();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scoreDelta = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_TurnSummary_ScoreDeltas {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      scoreDelta: isSet(object.scoreDelta) ? globalThis.Number(object.scoreDelta) : 0,
    };
  },

  toJSON(message: ServerPacket_TurnSummary_ScoreDeltas): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.scoreDelta !== 0) {
      obj.scoreDelta = Math.round(message.scoreDelta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_TurnSummary_ScoreDeltas>, I>>(
    base?: I,
  ): ServerPacket_TurnSummary_ScoreDeltas {
    return ServerPacket_TurnSummary_ScoreDeltas.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_TurnSummary_ScoreDeltas>, I>>(
    object: I,
  ): ServerPacket_TurnSummary_ScoreDeltas {
    const message = createBaseServerPacket_TurnSummary_ScoreDeltas();
    message.username = object.username ?? "";
    message.scoreDelta = object.scoreDelta ?? 0;
    return message;
  },
};

function createBaseServerPacket_PlayerGuessedTheWord(): ServerPacket_PlayerGuessedTheWord {
  return { username: "" };
}

export const ServerPacket_PlayerGuessedTheWord: MessageFns<ServerPacket_PlayerGuessedTheWord> = {
  encode(message: ServerPacket_PlayerGuessedTheWord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_PlayerGuessedTheWord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_PlayerGuessedTheWord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_PlayerGuessedTheWord {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: ServerPacket_PlayerGuessedTheWord): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_PlayerGuessedTheWord>, I>>(
    base?: I,
  ): ServerPacket_PlayerGuessedTheWord {
    return ServerPacket_PlayerGuessedTheWord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_PlayerGuessedTheWord>, I>>(
    object: I,
  ): ServerPacket_PlayerGuessedTheWord {
    const message = createBaseServerPacket_PlayerGuessedTheWord();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseServerPacket_LeaderBoard(): ServerPacket_LeaderBoard {
  return {};
}

export const ServerPacket_LeaderBoard: MessageFns<ServerPacket_LeaderBoard> = {
  encode(_: ServerPacket_LeaderBoard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_LeaderBoard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_LeaderBoard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ServerPacket_LeaderBoard {
    return {};
  },

  toJSON(_: ServerPacket_LeaderBoard): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_LeaderBoard>, I>>(base?: I): ServerPacket_LeaderBoard {
    return ServerPacket_LeaderBoard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_LeaderBoard>, I>>(_: I): ServerPacket_LeaderBoard {
    const message = createBaseServerPacket_LeaderBoard();
    return message;
  },
};

function createBaseServerPacket_PlayerMessage(): ServerPacket_PlayerMessage {
  return { from: "", message: "" };
}

export const ServerPacket_PlayerMessage: MessageFns<ServerPacket_PlayerMessage> = {
  encode(message: ServerPacket_PlayerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_PlayerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_PlayerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_PlayerMessage {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ServerPacket_PlayerMessage): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_PlayerMessage>, I>>(base?: I): ServerPacket_PlayerMessage {
    return ServerPacket_PlayerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_PlayerMessage>, I>>(object: I): ServerPacket_PlayerMessage {
    const message = createBaseServerPacket_PlayerMessage();
    message.from = object.from ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseServerPacket_PleaseChooseAWord(): ServerPacket_PleaseChooseAWord {
  return { words: [] };
}

export const ServerPacket_PleaseChooseAWord: MessageFns<ServerPacket_PleaseChooseAWord> = {
  encode(message: ServerPacket_PleaseChooseAWord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.words) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPacket_PleaseChooseAWord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPacket_PleaseChooseAWord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.words.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerPacket_PleaseChooseAWord {
    return { words: globalThis.Array.isArray(object?.words) ? object.words.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ServerPacket_PleaseChooseAWord): unknown {
    const obj: any = {};
    if (message.words?.length) {
      obj.words = message.words;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPacket_PleaseChooseAWord>, I>>(base?: I): ServerPacket_PleaseChooseAWord {
    return ServerPacket_PleaseChooseAWord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPacket_PleaseChooseAWord>, I>>(
    object: I,
  ): ServerPacket_PleaseChooseAWord {
    const message = createBaseServerPacket_PleaseChooseAWord();
    message.words = object.words?.map((e) => e) || [];
    return message;
  },
};

function createBaseClientPacket(): ClientPacket {
  return { drawingData: undefined, playerMessage: undefined, wordChoice: undefined, startGame: undefined };
}

export const ClientPacket: MessageFns<ClientPacket> = {
  encode(message: ClientPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.drawingData !== undefined) {
      DrawingData.encode(message.drawingData, writer.uint32(10).fork()).join();
    }
    if (message.playerMessage !== undefined) {
      ClientPacket_PlayerMessage.encode(message.playerMessage, writer.uint32(18).fork()).join();
    }
    if (message.wordChoice !== undefined) {
      ClientPacket_WordChoice.encode(message.wordChoice, writer.uint32(26).fork()).join();
    }
    if (message.startGame !== undefined) {
      ClientPacket_StartGame.encode(message.startGame, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.drawingData = DrawingData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerMessage = ClientPacket_PlayerMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wordChoice = ClientPacket_WordChoice.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startGame = ClientPacket_StartGame.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientPacket {
    return {
      drawingData: isSet(object.drawingData) ? DrawingData.fromJSON(object.drawingData) : undefined,
      playerMessage: isSet(object.playerMessage)
        ? ClientPacket_PlayerMessage.fromJSON(object.playerMessage)
        : undefined,
      wordChoice: isSet(object.wordChoice) ? ClientPacket_WordChoice.fromJSON(object.wordChoice) : undefined,
      startGame: isSet(object.startGame) ? ClientPacket_StartGame.fromJSON(object.startGame) : undefined,
    };
  },

  toJSON(message: ClientPacket): unknown {
    const obj: any = {};
    if (message.drawingData !== undefined) {
      obj.drawingData = DrawingData.toJSON(message.drawingData);
    }
    if (message.playerMessage !== undefined) {
      obj.playerMessage = ClientPacket_PlayerMessage.toJSON(message.playerMessage);
    }
    if (message.wordChoice !== undefined) {
      obj.wordChoice = ClientPacket_WordChoice.toJSON(message.wordChoice);
    }
    if (message.startGame !== undefined) {
      obj.startGame = ClientPacket_StartGame.toJSON(message.startGame);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientPacket>, I>>(base?: I): ClientPacket {
    return ClientPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientPacket>, I>>(object: I): ClientPacket {
    const message = createBaseClientPacket();
    message.drawingData = (object.drawingData !== undefined && object.drawingData !== null)
      ? DrawingData.fromPartial(object.drawingData)
      : undefined;
    message.playerMessage = (object.playerMessage !== undefined && object.playerMessage !== null)
      ? ClientPacket_PlayerMessage.fromPartial(object.playerMessage)
      : undefined;
    message.wordChoice = (object.wordChoice !== undefined && object.wordChoice !== null)
      ? ClientPacket_WordChoice.fromPartial(object.wordChoice)
      : undefined;
    message.startGame = (object.startGame !== undefined && object.startGame !== null)
      ? ClientPacket_StartGame.fromPartial(object.startGame)
      : undefined;
    return message;
  },
};

function createBaseClientPacket_StartGame(): ClientPacket_StartGame {
  return {};
}

export const ClientPacket_StartGame: MessageFns<ClientPacket_StartGame> = {
  encode(_: ClientPacket_StartGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientPacket_StartGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientPacket_StartGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClientPacket_StartGame {
    return {};
  },

  toJSON(_: ClientPacket_StartGame): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientPacket_StartGame>, I>>(base?: I): ClientPacket_StartGame {
    return ClientPacket_StartGame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientPacket_StartGame>, I>>(_: I): ClientPacket_StartGame {
    const message = createBaseClientPacket_StartGame();
    return message;
  },
};

function createBaseClientPacket_WordChoice(): ClientPacket_WordChoice {
  return { choice: 0 };
}

export const ClientPacket_WordChoice: MessageFns<ClientPacket_WordChoice> = {
  encode(message: ClientPacket_WordChoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.choice !== 0) {
      writer.uint32(8).int64(message.choice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientPacket_WordChoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientPacket_WordChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.choice = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientPacket_WordChoice {
    return { choice: isSet(object.choice) ? globalThis.Number(object.choice) : 0 };
  },

  toJSON(message: ClientPacket_WordChoice): unknown {
    const obj: any = {};
    if (message.choice !== 0) {
      obj.choice = Math.round(message.choice);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientPacket_WordChoice>, I>>(base?: I): ClientPacket_WordChoice {
    return ClientPacket_WordChoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientPacket_WordChoice>, I>>(object: I): ClientPacket_WordChoice {
    const message = createBaseClientPacket_WordChoice();
    message.choice = object.choice ?? 0;
    return message;
  },
};

function createBaseClientPacket_PlayerMessage(): ClientPacket_PlayerMessage {
  return { message: "" };
}

export const ClientPacket_PlayerMessage: MessageFns<ClientPacket_PlayerMessage> = {
  encode(message: ClientPacket_PlayerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientPacket_PlayerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientPacket_PlayerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientPacket_PlayerMessage {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ClientPacket_PlayerMessage): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientPacket_PlayerMessage>, I>>(base?: I): ClientPacket_PlayerMessage {
    return ClientPacket_PlayerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientPacket_PlayerMessage>, I>>(object: I): ClientPacket_PlayerMessage {
    const message = createBaseClientPacket_PlayerMessage();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseDrawingData(): DrawingData {
  return { data: new Uint8Array(0) };
}

export const DrawingData: MessageFns<DrawingData> = {
  encode(message: DrawingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrawingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrawingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrawingData {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: DrawingData): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrawingData>, I>>(base?: I): DrawingData {
    return DrawingData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrawingData>, I>>(object: I): DrawingData {
    const message = createBaseDrawingData();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
